\label{fig:architecture}
The \ldviews architecture
After the frames have been applied, the result is collections of JSON-LD documents, one collection per view.  
Each document contains the RDF neighborhood around the entity that corresponds to the type associated with a view.  
To support the end user queries, the documents need to be indexed accordingly.  

For maximum query performance, we create an inverted index for each field and the path associated with each nested field, which the framer has created by pre-computing the joins.  
For our example web page view,  we index both the schema:dateCreated of the web page in figure blahblah and the schema:name of the schema:mainEntity/schema:seller/schema:telephone.  
This allows us to find web pages that were crawled on the same day or find web pages that mention a particular telephone.  

Fortunately, Elasticsearch can handle this indexing process efficiently, creating the multitude of indexes simultaneously.  
Since Elasticsearch is primarily a text search engine it supports incredible flexibility in indexing free text.  
However, the index type chosen can also be informed by the RDFS type of the objects, which enables us to perform operations like date range and geospatial queries efficiently.
% Insert discussion on size of index on discuss versus input size. 

Admittedly, this represents an extreme approach compared to the common indexing approaches normally seen in RDF Triple Stores.  
According to \cite{luo2012storing}, without insight into the expected query load, the triple store must make a best effort to support ad hoc queries.  
As such, the chapter describes the handful indexes that can be built by permuting the subject, predicate, object, and optional context graph values that make up a triple or quad.
These indexes can either contain references to triples in unclustered indexes, or materialize them in clustered indexes, trading performance for space.
Virtuoso can create bitmaps for predicate object pairs to speed subject lookups, which can be quickly combined to satisfy multiple constraints, which is analogous to how Elasticsearch applies many filters. 
The important distinction in Virtuoso is that these bitmaps only enable filtering properties immediate to a subject, not property paths.
If the property paths are many steps away, the joins must still be computed.  


 