\section{Introduction}
SPARQL, the standard query language for RDF graphs is also the de-facto standard for building applications that consume Linked Data. 
Despite substantial research on optimizing SPARQL query processing \cite{Pham2013}, the computation of query solutions remains a computationally intensive task for large datasets.
As a result, it becomes challenging for maintainers of SPARQL endpoints to guarantee high availability.
For example, a recent survey \cite{buil2013sparql} revealed that less than half of the public endpoints reach an availability of 95\%.
The computational cost of SPARQL query answering also makes it challenging for application developers to build high performance applications serving large numbers of users.
Application developers often spend a substantial amount of time optimizing queries to support interactive applications \cite{Loizou_Angles_Groth_2014}.

Common approaches to address the availability and performance challenges involve restricting the types of queries that can be submitted to the SPARQL endpoint.
A simple approach is to restrict access to the endpoint using a Web API \cite{Groth_Loizou_Gray_Goble_Harland_Pettifer_2014}.
Each entry point in the API is implemented using a query template where the arguments in API invocations are substituted in the template to generate a SPARQL query.
Limiting queries using an API makes it possible to support highly available SPARQL endpoints as needed in production applications.
%
Verborgh et al. \cite{Verborgh2014} propose Link Data Fragments to restrict the types of queries that can be submitted to an endpoint. 
The approach splits query processing between the server and its clients.
Clients decompose complex queries into a collection of simpler, single triple pattern queries, that can be submitted to the server.
In this approach, servers only need to implement support for single triple pattern queries, making it possible to provide efficient response times and high availability for large numbers of clients.
The approach shifts the burden of implementing joins in the client, requiring many server requests to answer one query and significant data transfer between servers and clients. 
The approach trades off query performance for high endpoint availability, and is well suited for applications that query multiple endpoints, but don't need efficient query response times.

